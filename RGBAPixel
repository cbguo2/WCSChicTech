import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Objects;
import javax.imageio.ImageIO;
//with picture class, we just have to put the picture class in the same folder as the picture.java and rgba.java then that should print 

/**
 * Class representing a RGBA pixel.
 */
public class RGBAPixel extends Picture{ //pictureclass

	
	//Max value for the RGB Values.
    private static final int MAX_CHANNEL_VALUE = 255;
    private int blueValue;
    private int greenValue;
    private int redValue;

    public RGBAPixel(final int r, final int g,
                     final int b, String s) {
        super(s); //calls super constructor on picture class that takes string (we'll just use that class so we'll make sure they only upload jpg) or we can
        //work within the picture class but i think just limiting it's easier 
        //picture should already be in a 2D array, since this picture let's you manipulate pixels so we just have to figure out how they manipulate the pixels and go from 
        //there. 
        redValue = r;
        greenValue = g;
        blueValue = b;
        
        
    }  
    
    public RGBAPixel[][] getPixels2D(String s ) {
    	
    	
    	
    	
    }
    
    public int getRed() {
        return redValue;
    }

    /**
     * Get this pixel's green value.
     *
     * @return this pixel's green value
     */
    public int getGreen() {
        return greenValue;
    }

    /**
     * Get this pixel's blue value.
     *
     * @return this pixel's blue value
     */
    public int getBlue() {
        return blueValue;
    }

    public void setRed(final int setValue) {
        redValue = setValue;
    }
    
    public void setBlue(final int setValue) {
        blueValue = setValue;
    }
    
    public void setGreen(final int setValue) {
        greenValue = setValue;
    }

    //EDIT
    public String toString() {
        return "RGBAPixel{" ;
    }

    /*
     * Equals autogenerated by IntelliJ.
     */
    @Override
    public boolean equals(final Object o) {
        return false;
    }
    /*
     * hashCode autogenerated by IntelliJ.
     */
    @Override
    public int hashCode() {
        return 0;
    }


    /**
     * Perform a deep copy of a two-dimensional RGBAPixel array.
     * <p>
     * This is a convenience method largely for use by the testing suite.
     * Fails and returns null if top-level array has length 0, or if any inner array has length 0,
     * or if the two-dimensional array is not square.
     *
     * @param inputArray array of RGBAPixel objects to copy
     * @return copied array of RGBAPixel objects, or null on failure.
     */
    public static RGBAPixel[][] copyArray(final RGBAPixel[][] inputArray) {
        if (inputArray == null) {
            return null;
        }
        if (inputArray.length == 0) {
            return null;
        }
        RGBAPixel[][] returnArray = new RGBAPixel[inputArray.length][inputArray[0].length];
        for (int i = 0; i < inputArray.length; i++) {
           for (int j = 0; j < inputArray[i].length; j++) {
               returnArray[i][j] = new RGBAPixel(inputArray[i][j].getRed(), inputArray[i][j].getGreen(),
               inputArray[i][j].getBlue());

           }
        }
        
        return returnArray;
    }

    /**
     * Nicely format an two-dimensional array of RGBAPixels.
     * <p>
     * Primarily intended for debugging.
     *
     * @param inputArray the two-dimensional RGBAPixel array to format
     * @return the array nicely formatted as a String for printing
     */
    public static String printArray(final RGBAPixel[][] inputArray) {
        if (inputArray == null) {
            return null;
        }
        if (inputArray.length == 0) {
            return null;
        }
        /*
         * Make sure inputArray is square
         * */
        for (RGBAPixel[] anInputArray : inputArray) {
            if (anInputArray.length == 0 || anInputArray.length != inputArray[0].length) {
                return null;
            }
        }

        /*
         * Transpose inputArray
         */
        RGBAPixel[][] transposedArray = new RGBAPixel[inputArray[0].length][inputArray.length];
        for (int i = 0; i < inputArray.length; i++) {
            for (int j = 0; j < inputArray[0].length; j++) {
                transposedArray[j][i] = inputArray[i][j];
            }
        }

        /*
         * Finally create the output string array.
         */
        String[] outputArray = new String[transposedArray.length];
        for (int i = 0; i < transposedArray.length; i++) {
            outputArray[i] = Arrays.deepToString(transposedArray[i]);
        }

        return String.join("\n", outputArray);
    }

   
    
}

