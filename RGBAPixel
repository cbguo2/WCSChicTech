import java.awt.image.BufferedImage;
import java.io.File;
import java.io.IOException;
import java.util.Arrays;
import java.util.Objects;
import javax.imageio.ImageIO;
//with picture class, we just have to put the picture class in the same folder as the picture.java and rgba.java then that should print 

/**
 * Class representing a RGBA pixel.
 */
public class RGBAPixel extends Picture{ //pictureclass

	
	//Max value for the RGB Values.
    private static final int MAX_CHANNEL_VALUE = 255;
    private int blueValue;
    private int greenValue;
    private int redValue;

    public RGBAPixel(String s) {
        super(s); //calls super constructor on picture class that takes string (we'll just use that class so we'll make sure they only upload jpg) or we can
        //work within the picture class but i think just limiting it's easier 
        //picture should already be in a 2D array, since this picture let's you manipulate pixels so we just have to figure out how they manipulate the pixels and go from 
        //there. 

        
    }  
    
    
    public int getRed() {
        return redValue;
    }

    /**
     * Get this pixel's green value.
     *
     * @return this pixel's green value
     */
    public int getGreen() {
        return greenValue;
    }

    /**
     * Get this pixel's blue value.
     *
     * @return this pixel's blue value
     */
    public int getBlue() {
        return blueValue;
    }

    public void setRed(final int setValue) {
        redValue = setValue;
    }
    
    public void setBlue(final int setValue) {
        blueValue = setValue;
    }
    
    public void setGreen(final int setValue) {
        greenValue = setValue;
    }

    //EDIT
    public String toString() {
        return "RGBAPixel{" ;
    }

    /*
     * Equals autogenerated by IntelliJ.
     */
    @Override
    public boolean equals(final Object o) {
        return false;
    }
    /*
     * hashCode autogenerated by IntelliJ.
     */
    @Override
    public int hashCode() {
        return 0;
    }


    /**
     * Perform a deep copy of a two-dimensional RGBAPixel array.
     * <p>
     * This is a convenience method largely for use by the testing suite.
     * Fails and returns null if top-level array has length 0, or if any inner array has length 0,
     * or if the two-dimensional array is not square.
     *
     * @param inputArray array of RGBAPixel objects to copy
     * @return copied array of RGBAPixel objects, or null on failure.
     */
//    public static RGBAPixel[][] copyArray(final RGBAPixel[][] inputArray) {
//        if (inputArray == null) {
//            return null;
//        }
//        if (inputArray.length == 0) {
//            return null;
//        }
//        RGBAPixel[][] returnArray = new RGBAPixel[inputArray.length][inputArray[0].length];
//        for (int i = 0; i < inputArray.length; i++) {
//           for (int j = 0; j < inputArray[i].length; j++) {
//               returnArray[i][j] = new RGBAPixel(inputArray[i][j].getRed(), inputArray[i][j].getGreen(),
//               inputArray[i][j].getBlue());
//
//           }
//        }
//        
//        return returnArray;
//    }
    
    public void Chromakey(Picture newPic){
  	  //initialize the pixels in the green screen picture and the background picture
  	  
  	  
  	  //create a nested for loop to traverse through the newPic (green screen picture) to find		    the green pixels and replace them with the pixel at the same location from the			    background picture
  	  for (int row = 0; row < newPic.width(); row++){
  	      for (int col = 0; col <= newPic.height(); col++){
  	    	  
  	    	 //create local variables to store the rgb values from a pixel at a specific location
  	    	 int red = newPic.getRed();
  	    	 int green = newPixels[row][col].getGreen();
  	    	 int blue= newPixels[row][col].getBlue();
  	    	
  	    	 //the if statement tests if the green value is bigger than the red and blue values
  	    	 //the +30 is to make sure that the pixel is truly green - acts like a "buffer zone”
  	    	 if(green > red + 30 && green > blue + 30) {
  	    		
   //if the green value is bigger than the red and blue values, replace the		   pixel at that location with the pixel at the same location from the			   background picture
  	    		 newPixels[row][col].setColor(pixels[row][col].getColor());
      		 }
  	      }
  	 } 
    }


    /**
     * Nicely format an two-dimensional array of RGBAPixels.
     * <p>
     * Primarily intended for debugging.
     *
     * @param inputArray the two-dimensional RGBAPixel array to format
     * @return the array nicely formatted as a String for printing
     */
    public static String printArray(final RGBAPixel[][] inputArray) {
        if (inputArray == null) {
            return null;
        }
        if (inputArray.length == 0) {
            return null;
        }
        /*
         * Make sure inputArray is square
         * */
        for (RGBAPixel[] anInputArray : inputArray) {
            if (anInputArray.length == 0 || anInputArray.length != inputArray[0].length) {
                return null;
            }
        }

        /*
         * Transpose inputArray
         */
        RGBAPixel[][] transposedArray = new RGBAPixel[inputArray[0].length][inputArray.length];
        for (int i = 0; i < inputArray.length; i++) {
            for (int j = 0; j < inputArray[0].length; j++) {
                transposedArray[j][i] = inputArray[i][j];
            }
        }

        /*
         * Finally create the output string array.
         */
        String[] outputArray = new String[transposedArray.length];
        for (int i = 0; i < transposedArray.length; i++) {
            outputArray[i] = Arrays.deepToString(transposedArray[i]);
        }

        return String.join("\n", outputArray);
    }

   
    
}

